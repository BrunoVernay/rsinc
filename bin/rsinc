#!/usr/bin/env python3
# -*- coding: utf-8 -*-

print('''
Copyright 2019 C. J. Williams (CHURCHILL COLLEGE)
This is free software with ABSOLUTELY NO WARRANTY''')

import argparse
import os
import subprocess
import ujson as json
import logging
from datetime import datetime

import halo
from clint.textui import colored

import rsinc

CONFIG_FILE = os.path.expanduser('~/.rsinc/config.json')  # Default config


# ****************************************************************************
# *                                 Functions                                *
# ****************************************************************************


def qt(string):
    return '"' + string + '"'


def read(file):
    '''Reads json do dict and returns dict'''
    with open(file, 'r') as fp:
        d = json.load(fp)

    return d


def write(file, d):
    '''Writes dict to json'''
    if not dry_run:
        with open(file, 'w') as fp:
            json.dump(d, fp, sort_keys=True, indent=2)


def empty():
    '''Returns dict representing empty directory'''
    return {'fold': {}, 'file': {}}


def insert(nest, chain):
    '''Inserts element at the end of the chain into packed dict, nest'''
    if len(chain) == 2:
        nest['file'].update({chain[0]: chain[1]})
        return

    if chain[0] not in nest['fold']:
        nest['fold'].update({chain[0]: empty()})

    insert(nest['fold'][chain[0]], chain[1:])


def pack(flat):
    '''Converts flat, into packed dict'''
    nest = empty()
    for file in flat.files:
        chain = file.name.split(
            '/') + [{'uid': file.uid, 'datetime': file.time}]
        insert(nest, chain)

    return nest


def unpack(nest, flat, path=''):
    '''Converts packed dict, nest, into flat'''
    for k, v in nest['file'].items():
        flat.update(path + k, v['uid'], v['datetime'])

    for k, v in nest['fold'].items():
        unpack(v, flat, path + k + '/')


def _get_branch(nest, chain):
    '''Returns packed dict at end of chain in packed dict, nest'''
    if len(chain) == 0:
        return nest
    else:
        return _get_branch(nest['fold'][chain[0]], chain[1:])


def get_branch(nest, path):
    '''Helper function for _get_branch, converts path to chain'''
    return _get_branch(nest, path.split('/'))


def _merge(nest, chain, new):
    '''Merge packed dict, new, into packed dict, nest, at end of chain'''
    if len(chain) == 1:
        nest['fold'].update({chain[0]: new})
        return

    if chain[0] not in nest['fold']:
        nest['fold'].update({chain[0]: empty()})

    _merge(nest['fold'][chain[0]], chain[1:], new)


def merge(nest, path, new):
    '''Helper function for _merge, converts path to chain'''
    _merge(nest, path.split('/'), new)


def _have(nest, chain):
    '''Returns: true if chain is contained in packed dict, nest, else: false'''
    if chain[0] in nest['fold']:
        if len(chain) == 1:
            return True
        else:
            return _have(nest['fold'][chain[0]], chain[1:])

    return False


def have(master, path):
    '''Helper function for _have, converts path to chain'''
    return _have(master, path.split('/'))


# ****************************************************************************
# *                             Parsing Arguments                            *
# ****************************************************************************


parser = argparse.ArgumentParser()

parser.add_argument("folders", help="Folders to sync", nargs='*')
parser.add_argument("-d", "--dry", action="store_true", help="Do a dry run")
parser.add_argument("-c", "--clean", action="store_true",
                    help="Clean directories")
parser.add_argument("-D", "--default", help="Sync defaults",
                    action="store_true")
parser.add_argument("-r", "--recovery", action="store_true",
                    help="Enter recovery mode")
parser.add_argument("-a", "--auto", help="Don't ask permissions",
                    action="store_true")
parser.add_argument("-p", "--purge", help="Reset history for all folders",
                    action="store_true")
parser.add_argument(
    "--config", help="Path to config file (default ~/.rsinc/config.json)")


args = parser.parse_args()


# ****************************************************************************
# *                           Definitions / Set-up                           *
# ****************************************************************************


if args.config == None:
    config = read(CONFIG_FILE)
else:
    config = read(args.config)

BASE_R = config['BASE_R']
BASE_L = config['BASE_L']
CASE_INSENSATIVE = config['CASE_INSENSATIVE']
HASH_NAME = config['HASH_NAME']
DEFAULT_DIRS = config['DEFAULT_DIRS']
MASTER = config['MASTER']
LOG_FOLDER = config['LOG_FOLDER']
TEMP_FILE = config['TEMP_FILE']

strtobool = {'yes': True, 'ye': True, 'y': True, 'n': False, 'no': False,
             '1': True, "0": False, 't': True, 'true': True, 'f': False,
             'false': False, 'Y': True, 'N': False, 'Yes': True, "No": False,
             '': True}

ylw = colored.yellow   # warn
red = colored.red      # error
grn = colored.green    # info

spin = halo.Halo(spinner='dots', placement='right', color='yellow')

# Decide which folder(s) to sync
CWD = os.getcwd()
cwd = CWD.split('/')
for elem in BASE_L.split('/')[:-1]:
    if cwd[0] == elem:
        cwd.pop(0)
    else:
        cwd = DEFAULT_DIRS
        break
else:
    if len(cwd) == 0:
        cwd = DEFAULT_DIRS
    else:
        cwd = ['/'.join(cwd)]

# Set up logging
logging.basicConfig(filename=LOG_FOLDER + datetime.now().strftime('%Y-%m-%d'),
                    level=logging.DEBUG,
                    datefmt='%H:%M:%S',
                    format='%(asctime)s %(levelname)s: %(message)s',)

if args.default:
    folders = DEFAULT_DIRS
elif args.folders == []:
    folders = cwd
else:
    folders = args.folders

dry_run = args.dry
auto = args.auto
recover = args.recovery


# ****************************************************************************
# *                               Main Program                               *
# ****************************************************************************


if args.purge:
    print(ylw('WARN'), 'Purging history of all folders')
    write(MASTER, empty())

# get the master structure
if not os.path.exists(MASTER):
    print(ylw('WARN'), MASTER, 'missing, this must be your first run')
    write(MASTER, empty())

master = read(MASTER)

if os.path.exists(TEMP_FILE):
    corrupt = read(TEMP_FILE)['folder']
    if corrupt in folders:
        folders.remove(corrupt)

    folders.insert(0, corrupt)
    recover = True
    print(red('ERROR') + ', detected a crash, recovering', corrupt)
    logging.warning('Detected crash, recovering %s', corrupt)

for folder in folders:
    print('')
    save = False

    path_lcl = BASE_L + folder + '/'
    path_rmt = BASE_R + folder + '/'

    # Determine if first run
    if have(master, folder):
        print(grn('Have:'), qt(folder) + ', entering sync & merge mode')
    else:
        print(ylw('Don\'t have:'), qt(folder) + ', entering first_sync mode')
        recover = True

    # Scan directories
    spin.start(("Crawling: ") + qt(folder))

    lcl = rsinc.lsl(path_lcl, HASH_NAME)
    rmt = rsinc.lsl(path_rmt, HASH_NAME)
    old = rsinc.Flat('old')

    spin.stop_and_persist(symbol='✔')

    # First run & recover mode
    if recover:
        print('Running', ylw('recover/first_sync'), 'mode')
        save = True
    else:
        print('Reading last state.')
        branch = get_branch(master, folder)
        unpack(branch, old)

        rsinc.calc_states(old, lcl)
        rsinc.calc_states(old, rmt)

    # Main logic
    print(grn('Dry pass:'))
    count = rsinc.sync(lcl, rmt, old, recover,
                       dry_run=True, case=CASE_INSENSATIVE)

    if dry_run:
        print('Found:', count, 'job(s)')
    else:
        if count == 0:
            print('Found no jobs')
        elif auto or strtobool[input('Execute? ')]:
            print(grn("Live pass:"))
            save = True

            write(TEMP_FILE, {'folder': folder})
            rsinc.sync(lcl, rmt, old, recover, dry_run=dry_run,
                       total=count, case=CASE_INSENSATIVE)

        if args.clean:
            spin.start(grn('Pruning: ') + qt(folder))

            subprocess.run(["rclone", 'rmdirs', path_rmt])
            subprocess.run(["rclone", 'rmdirs', path_lcl])

            spin.stop_and_persist(symbol='✔')

    # Merge into master and clean up
    if save:
        spin.start(grn('Saving: ') + qt(folder))

        merge(master, min_path, pack(rsinc.lsl(BASE_L + min_path, HASH_NAME)))
        write(MASTER, master)

        if os.path.exists(TEMP_FILE):
            subprocess.run(["rm", TEMP_FILE])

        spin.stop_and_persist(symbol='✔')

    recover = args.recovery

print('')
print(grn("All synced!"))
