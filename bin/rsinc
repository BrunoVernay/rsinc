#!/usr/bin/env python3
# -*- coding: utf-8 -*-

print('''
Copyright 2019 C. J. Williams (CHURCHILL COLLEGE)
This is free software with ABSOLUTELY NO WARRANTY''')

import argparse
import os
import subprocess
import logging
from datetime import datetime

import ujson as json
import halo
from clint.textui import colored

import rsinc

CONFIG_FILE = os.path.expanduser('~/.rsinc/config.json')  # Default config path


# ****************************************************************************
# *                                 Functions                                *
# ****************************************************************************


def qt(string):
    return '"' + string + '"'


def read(file):
    '''Reads json do dict and returns dict.'''
    with open(file, 'r') as fp:
        d = json.load(fp)

    return d


def write(file, d):
    '''Writes dict to json'''
    with open(file, 'w') as fp:
        json.dump(d, fp, sort_keys=True, indent=2)


def empty():
    '''Returns dict representing empty directory.'''
    return {'fold': {}, 'file': {}}


def insert(nest, chain):
    '''Inserts element at the end of the chain into packed dict, nest.'''
    if len(chain) == 2:
        nest['file'].update({chain[0]: chain[1]})
        return

    if chain[0] not in nest['fold']:
        nest['fold'].update({chain[0]: empty()})

    insert(nest['fold'][chain[0]], chain[1:])


def pack(flat):
    '''Converts flat, into packed dict.'''
    nest = empty()
    for name, file in flat.names.items():
        chain = name.split('/') + [file.uid]
        insert(nest, chain)

    return nest


def unpack(nest, flat, path=''):
    '''Converts packed dict, nest, into flat.'''
    for k, v in nest['file'].items():
        flat.update(path + k, v)

    for k, v in nest['fold'].items():
        unpack(v, flat, path + k + '/')


def _get_branch(nest, chain):
    '''Returns packed dict at end of chain in packed dict, nest.'''
    if len(chain) == 0:
        return nest
    else:
        return _get_branch(nest['fold'][chain[0]], chain[1:])


def get_branch(nest, path):
    '''Helper function for _get_branch, converts path to chain.'''
    return _get_branch(nest, path.split('/'))


def _merge(nest, chain, new):
    '''Merge packed dict, new, into packed dict, nest, at end of chain.'''
    if len(chain) == 1:
        nest['fold'].update({chain[0]: new})
        return

    if chain[0] not in nest['fold']:
        nest['fold'].update({chain[0]: empty()})

    _merge(nest['fold'][chain[0]], chain[1:], new)


def merge(nest, path, new):
    '''Helper function for _merge, converts path to chain.'''
    _merge(nest, path.split('/'), new)


def _have(nest, chain):
    '''Returns: true if chain is contained in packed dict, nest, else: false.'''
    if chain[0] in nest['fold']:
        if len(chain) == 1:
            return True
        else:
            return _have(nest['fold'][chain[0]], chain[1:])

    return False


# ****************************************************************************
# *                             Parsing Arguments                            *
# ****************************************************************************


parser = argparse.ArgumentParser()

parser.add_argument("folders", help="Folders to sync", nargs='*')
parser.add_argument("-d", "--dry", action="store_true", help="Do a dry run")
parser.add_argument("-c", "--clean", action="store_true",
                    help="Clean directories")
parser.add_argument("-D", "--default", help="Sync defaults",
                    action="store_true")
parser.add_argument("-r", "--recovery", action="store_true",
                    help="Enter recovery mode")
parser.add_argument("-a", "--auto", help="Don't ask permissions",
                    action="store_true")
parser.add_argument("-p", "--purge", help="Reset history for all folders",
                    action="store_true")
parser.add_argument(
    "--config", help="Path to config file (default ~/.rsinc/config.json)")


args = parser.parse_args()
dry_run = args.dry
auto = args.auto
recover = args.recovery


# ****************************************************************************
# *                           Definitions / Set-up                           *
# ****************************************************************************

# Read config and assign variables.
if args.config == None:
    config = read(CONFIG_FILE)
else:
    config = read(args.config)

BASE_R = config['BASE_R']
BASE_L = config['BASE_L']
CASE_INSENSATIVE = config['CASE_INSENSATIVE']
HASH_NAME = config['HASH_NAME']
DEFAULT_DIRS = config['DEFAULT_DIRS']
MASTER = config['MASTER']
LOG_FOLDER = config['LOG_FOLDER']
TEMP_FILE = config['TEMP_FILE']
HISTORY = config['HISTORY']

strtobool = {'yes': True, 'ye': True, 'y': True, 'n': False, 'no': False,
             '1': True, "0": False, 't': True, 'true': True, 'f': False,
             'false': False, 'Y': True, 'N': False, 'Yes': True, "No": False,
             '': True}

ylw = colored.yellow   # warn
red = colored.red      # error
grn = colored.green    # info

spin = halo.Halo(spinner='dots', placement='right', color='yellow')

# Decide which folder(s) to sync.
cwd = os.getcwd()

if args.default:
    tmp = DEFAULT_DIRS
elif len(args.folders) == 0:
    tmp = [cwd]
else:
    tmp = []
    for f in args.folders:
        if f[0] == '/':
            tmp.append(f)
        else:
            tmp.append(cwd + '/' + f)

folders = []
for f in tmp:
    if len(f) < len(BASE_L):
        print('Rejecting', f, 'not in', BASE_L)
        continue
    for b, c in zip(BASE_L, f):
        if b != c:
            print('Rejecting', f, 'not in', BASE_L)
            break
    else:
        folders.append(f[len(BASE_L):])

if len(folders) == 0:
    folders = DEFAULT_DIRS


# Set up logging.
logging.basicConfig(filename=LOG_FOLDER + datetime.now().strftime('%Y-%m-%d'),
                    level=logging.DEBUG,
                    datefmt='%H:%M:%S',
                    format='%(asctime)s %(levelname)s: %(message)s',)


# ****************************************************************************
# *                               Main Program                               *
# ****************************************************************************


if args.purge:
    print(ylw('WARN:'), 'Purging history of all folders')
    write(MASTER, empty())
    write(HISTORY, set())

if not os.path.exists(MASTER):
    print(ylw('WARN:'), MASTER, 'missing, this must be your first run')
    write(MASTER, empty())

if not os.path.exists(HISTORY):
    print(ylw('WARN:'), HISTORY, 'missing')
    write(HISTORY, set())

master = read(MASTER)
history = set(read(HISTORY))

if os.path.exists(TEMP_FILE):
    corrupt = read(TEMP_FILE)['folder']
    if corrupt in folders:
        folders.remove(corrupt)

    folders.insert(0, corrupt)
    recover = True
    print(red('ERROR') + ', detected a crash, recovering', corrupt)
    logging.warning('Detected crash, recovering %s', corrupt)

for folder in folders:
    print('')
    path_lcl = BASE_L + folder + '/'
    path_rmt = BASE_R + folder + '/'

    # Determine if first run.
    if folder in history:
        print(grn('Have:'), qt(folder) + ', entering sync & merge mode')
    else:
        print(ylw('Don\'t have:'), qt(folder) + ', entering first_sync mode')
        recover = True

    # Scan directories.
    spin.start(("Crawling: ") + qt(folder))

    lcl = rsinc.lsl(path_lcl, HASH_NAME)
    rmt = rsinc.lsl(path_rmt, HASH_NAME)
    old = rsinc.Flat('old')

    spin.stop_and_persist(symbol='✔')

    # First run & recover mode.
    if recover:
        print('Running', ylw('recover/first_sync'), 'mode')
    else:
        print('Reading last state.')
        branch = get_branch(master, folder)
        unpack(branch, old)

        rsinc.calc_states(old, lcl)
        rsinc.calc_states(old, rmt)

    print(grn('Dry pass:'))
    total = rsinc.sync(lcl, rmt, old, recover,
                       dry_run=True, case=CASE_INSENSATIVE)

    print('Found:', total, 'job(s)')

    if not dry_run and (auto or total == 0 or strtobool[input('Execute? ')]):
        if total != 0 or recover:
            print(grn("Live pass:"))

            write(TEMP_FILE, {'folder': folder})
            rsinc.sync(lcl, rmt, old, recover, dry_run=dry_run,
                       total=total, case=CASE_INSENSATIVE)

            # Merge into master and clean up.
            spin.start(grn('Saving: ') + qt(folder))

            merge(master, folder, pack(rsinc.lsl(BASE_L + folder, HASH_NAME)))
            write(MASTER, master)

            subprocess.run(["rm", TEMP_FILE])
            spin.stop_and_persist(symbol='✔')

        if recover:
            # Merge into history.
            command = ['rclone', 'lsjson', '-R', '--dirs-only', path_lcl]
            result = subprocess.Popen(command, stdout=subprocess.PIPE)
            dirs = json.load(result.stdout)
            history.add(folder)
            history.update(folder + '/' + d['Path'] for d in dirs)
            write(HISTORY, history)

    if args.clean:
        spin.start(grn('Pruning: ') + qt(folder))

        subprocess.run(["rclone", 'rmdirs', path_rmt])
        subprocess.run(["rclone", 'rmdirs', path_lcl])

        spin.stop_and_persist(symbol='✔')

    recover = args.recovery

print('')
print(grn("All synced!"))
